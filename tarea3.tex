% Template:     Informe/Reporte LaTeX
% Documento:    Archivo principal
% Versión:      5.1.2 (09/05/2018)
% Codificación: UTF-8
%
% Autor: Pablo Pizarro R. @ppizarror
%        Facultad de Ciencias Físicas y Matemáticas
%        Universidad de Chile
%        pablo.pizarro@ing.uchile.cl, ppizarror.com
%
% Manual template: [http://latex.ppizarror.com/Template-Informe/]
% Licencia MIT:    [https://opensource.org/licenses/MIT/]

% CREACIÓN DEL DOCUMENTO
\documentclass[letterpaper,11pt]{article} % Articulo tamaño carta, 11pt
\usepackage[utf8]{inputenc} % Codificación UTF-8

% INFORMACIÓN DEL DOCUMENTO
\def\titulodelinforme {Informe Tarea N° 3}
\def\temaatratar {\LARGE\texttt{Cálculo de derivadas usando árboles binarios}}

\def\autordeldocumento {Sebastián Sepúlveda}
\def\nombredelcurso {Algoritmo y Estructura de datos}
\def\codigodelcurso {CC3001- 1}

\def\nombreuniversidad {Universidad de Chile}
\def\nombrefacultad {Facultad de Ciencias Físicas y Matemáticas}
\def\departamentouniversidad {Departamento de Ciencias de la Computación}
\def\imagendepartamento {departamentos/dcc}
\def\imagendepartamentoescala {0.2}
\def\localizacionuniversidad {Santiago, Chile}


% INTEGRANTES, PROFESORES Y FECHAS
\def\tablaintegrantes {
\begin{tabular}{ll}
	Nombre:
		& \begin{tabular}[t]{@{}l@{}}
			Sebastián Sepúlveda
		\end{tabular} \\
	Profesor:
		& \begin{tabular}[t]{@{}l@{}}
			Patricio Pobrete
		\end{tabular} \\
	Auxiliares:
		& \begin{tabular}[t]{@{}l@{}}
			Gabriel Flores M. \\
			Sven Reisenegger M.
		\end{tabular} \\
	\multicolumn{2}{l}{Fecha de entrega: 28/05/2018} 
\end{tabular}
}

% CONFIGURACIONES
\input{lib/config}
\def\importtikz{true}
% ESTILO PORTADA Y HEADER-FOOTER
\def\hfstyle {style3}             
\def\portraitstyle {style6}       

% IMPORTACIÓN DE LIBRERÍAS
\input{lib/env/imports}
% IMPORTACIÓN DE FUNCIONES Y ENTORNOS
\input{lib/cmd/all}

% IMPORTACIÓN DE ESTILOS
\input{lib/style/all}
% CONFIGURACIÓN INICIAL DEL DOCUMENTO
\input{lib/cfg/init}
\usepackage{wrapfig}
\usepackage[spanish]{babel}
%\usepackage{pifont}
\usetikzlibrary{babel,quotes,positioning,arrows,snakes,backgrounds,fit,trees,arrows,matrix}

% INICIO DE LAS PÁGINAS
\begin{document}

% PORTADA 
\input{lib/page/portrait}

% CONFIGURACIÓN DE PÁGINA Y ENCABEZADOS
\input{lib/cfg/page}

% TABLA DE CONTENIDOS - ÍNDICE
\input{lib/page/index} % Índice, se puede borrar

% CONFIGURACIONES FINALES
\input{lib/cfg/final}

% ======================= INICIO DEL DOCUMENTO =======================

% ======================= INTRODUCCION =======================
\sectionanum{Introducción}

El problema que se va a abordar en este informe será la construcción de un árbol de expresión aritmetica a partir de una expresión textual (contenida en un String)	escrita	en notación	polaca	inversa, calcular su derivada respecto a la variable solicitada por el usuario y publicar el resultado.
\newp
La notación polaca es una notación matemática en la que los operandos preceden a los operadores, esta notación no requiere uso de paréntesis, ya que no contiene ambigüedades.\\
Por ejemplo la expresión $$> >\ (5 / (7*x)) + (y+4)$$
Se representaria en notación polaca de la siguiente manera:

%Lista notación polaca
\begin{table}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\cline{1-9}
$5$ & $7$ & $x$ & $*$ & $/$ & $y$ & $4$ & $+$ & $+$\\
\cline{1-9}
\end{tabular}
\end{table}
\newp
Según el problema propuesto para la elaboración de este informe, el caso anterior quedaría representado por el siguiente árbol de expresión:\\

%DIBUJO 1 colores: yellow, green, red, blue, brown
\begin{figure}[!h]
\centering
\begin{tikzpicture}[level distance=1.3cm,
   level 1/.style={sibling distance=6cm, level distance=1cm},
   level 2/.style={sibling distance=3cm, level distance=1cm},
   level 3/.style={sibling distance=1.5cm, level distance=1cm}]%Se ocupo para poder separar el arbol creado en una distancia dada
\tikzstyle{every node}=[inner sep=0pt,minimum size=9mm, node distance=0.5pt]% define el cómo será cada nodo
\tikzstyle{edge from parent}=[red,->,thick,draw] %define el trazado o conexion que abrá entre cada nodo
\node [circle,draw=red!50,fill=red!20]{$+$}%cabeza
	child {node [circle,draw=red!50,fill=red!20]{$+$}%hijo izq
		child {node [circle,draw=yellow!50,fill=yellow!20]{$5$}}
		child {node [circle,draw=red!50,fill=red!20]{$/$}
			child {node [circle,draw=yellow!50,fill=yellow!20]{$7$}}
			child {node [circle,draw=green!50,fill=green!20]{$x$}}
	}
}
	child {node [circle,draw=red!50,fill=red!20]{$+$}%hijo der
		child {node [circle,draw=green!50,fill=green!20]{$y$}}
		child {node [circle,draw=yellow!50,fill=yellow!20]{$4$}}
};
\end{tikzpicture}
\end{figure}

Esta última expresión junto con el uso de pilas, será la que nos ayudará a obtener el resultado final requerido. El output del programa daria un resultado como el siguiente, si derivamos con respecto a la variable $x$:
$$> >\ 7 * (5 - y) / (5 - y) * (5 - y)$$
En el resultado final anterior se considero que $y\neq 5$.

% ======================= DISEÑO DE LA SOLUCIÓN =======================
\newpage
\sectionanum{Análisis del problema}
\subsectionanum{Construcción del árbol de expresión}
Para comenzar con la creación de la solución al problema, se buscó el método de leer el input que ingresaba el usuario, por lo que se asumió que \textit{el usuario ingresará la expresión solamente con la notación polaca inversa, y con espacio entre cada término que ingrese.}
\newp Se le pedirá al usuario que ingrese primero la expresión en matemática que desea derivar en polaca inversa, y luego que ingrese la variable que desea derivar. Es importante señalar que para nuestro programa se pensó en el uso de cualquier letra del abecedario castellano como variable que puede utilizar el usuario, teniendo como restricción la utilización de variables de sólo un carácter.
\newp Luego, se buscó la manera de obtener el árbol binario que represente la expresión entregada por el usuario, construyendo una pila de nodos convenientemente definidos tal que al final del algoritmo la pila contenga un solo elemento que será precisamente el árbol por encontrar. 
\begin{itemize}
\item Si el símbolo que se lee es un número o una variable, se crea un nodo con ese valor y se hace 
\textit{push} a la pila.

\item Si el símbolo que se lee es una operación, entonces se crea un nodo, con el valor de esa 
operación, tal que sus hijos son los elementos del stack que le siguen. El siguiente elemento 
será su nodo derecho y el otro el izquierdo.
\end{itemize}

En el programa, luego de devolver el \texttt{String} reprentante de la expresión, se señalará si este posee una división por cero, donde será necesario que el usuario ingrese nuevamente la expresión correcta que desee derivar para encontrar el resultado requerido.
\newp Un ejemplo de lo que realiza el método \texttt{StackConstructor} se visualiza en la siguiente secuencia de figuras, donde finalmente B es el árbol de la expresión ingresada en [$1$]:

\begin{table}[H]
\begin{minipage}[b]{0.2\linewidth}\centering
\begin{tikzpicture}
\node at (-4,0) [rectangle,draw=black!50,fill=black!20,minimum size=5mm] {1};
\node at (2,0) [circle,draw=red!50,fill=red!20,thick,minimum size=9mm] {$*$};
\node at (1,0) [circle,draw=red!50,fill=red!20,thick,minimum size=9mm] {$/$};
\node at (0,0) [circle,draw=blue!50,fill=blue!20,thick,minimum size=9mm] {$3$};
\node at (-1,0) [circle,draw=blue!50,fill=blue!20,thick,minimum size=9mm] {$x$};
\node at (-2,0) [circle,draw=blue!50,fill=blue!20,thick,minimum size=9mm] {$2$};
\end{tikzpicture}
\end{minipage}
\hspace{7cm} % Cambiar este espacio
\begin{minipage}[b]{0.2\linewidth}
\centering
\begin{tabular}{|ccc|}
& & \\ \hline
&  & \\ \hline
&  & \\ \hline
&  & \\ \hline
\end{tabular}
\end{minipage}
\end{table}

\definecolor{Light Yellow}{rgb}{1,1,0.75}
\definecolor{Brown}{rgb}{0.952,0.892,0.816}
\definecolor {Green Pale}{rgb}{0.7,1.004,0.7}
\begin{table}[H]
\begin{minipage}[b]{0.2\linewidth}\centering
\tikzstyle{place}=[circle,draw=blue!50,fill=blue!20,thick,minimum size=9mm]
\begin{tikzpicture}
\node at (-4,0) [rectangle,draw=black!50,fill=black!20,minimum size=5mm] {2};
\node at (0,0) [circle,draw=yellow!50,fill=yellow!20,thick,minimum size=9mm] {$3$};
\node at (-1,0) [circle,draw=green!50,fill=green!20,thick,minimum size=9mm] {$x$};
\node at (-2,0) [circle,draw=yellow!50,fill=yellow!20,thick,minimum size=9mm] {$2$};
\end{tikzpicture}
\end{minipage}
\hspace{7cm} % Cambiar este espacio
\begin{minipage}[b]{0.2\linewidth}
\centering
{\setlength{\arrayrulewidth}{1pt}
\begin{tabular}{|ccc|}
& & \\ 
\hline
\rowcolor{Light Yellow}
 & $3$ & \\ 
\hline
\rowcolor{Green Pale}
 & $x$ & \\ 
\hline
\rowcolor{Light Yellow}
& $2$ & \\ \hline
\end{tabular}
}
\end{minipage}
\end{table}

\begin{table}[H]
\begin{minipage}[b]{0.2\linewidth}\centering
\tikzstyle{place}=[circle,draw=brown!50,fill=brown!20,thick,minimum size=9mm]
\begin{tikzpicture}
\node at (-4,0) [rectangle,draw=black!50,fill=black!20,minimum size=5mm] {3};
\node at (-2,0) [place] {$A$};
\draw[line width=0.6mm] (-0.5,0.1) -- +(1,0) node[above] {};
\draw[line width=0.6mm] (-0.5,-0.1) -- +(1,0) node[above] {};
\end{tikzpicture}
\end{minipage}
\hspace{2cm} % Cambiar este espacio
\begin{minipage}[b]{0.2\linewidth}\centering
\begin{tikzpicture}[level distance=1.3cm,
level 1/.style={sibling distance=2cm, level distance=0.8cm},
level 2/.style={sibling distance=1cm, level distance=0.8cm},
level 3/.style={sibling distance=0.5cm, level distance=0.8cm}]%Se ocupo para poder separar el arbol creado en una distancia dada
\tikzstyle{every node}=[inner sep=0pt,minimum size=9mm, node distance=0.5pt]% define el cómo será cada nodo
\tikzstyle{edge from parent}=[red,->,thick,draw] %define el trazado o conexion que abrá entre cada nodo
\node [circle,draw=red!50,fill=red!20,thick]{$/$}%cabeza
child {node [circle,draw=green!50,fill=green!20,thick]{$x$}}
child {node [circle,draw=yellow!50,fill=yellow!20,thick]{$3$}%hijo der
};
\end{tikzpicture}
\end{minipage}
\hspace{2cm} % Cambiar este espacio
\begin{minipage}[b]{0.2\linewidth}
\centering
{\setlength{\arrayrulewidth}{1pt}
\begin{tabular}{|ccc|}
& & \\ \hline
&  & \\ \hline
\rowcolor {Brown}
& $A$ & \\ \hline
\rowcolor{Light Yellow}
& $2$ & \\ \hline
\end{tabular}
}
\end{minipage}
\end{table}

\begin{table}[H]
\begin{minipage}[b]{0.2\linewidth}\centering
\tikzstyle{place}=[circle,draw=brown!50,fill=brown!20,thick,minimum size=9mm]
\begin{tikzpicture}
\node at (-4,0) [rectangle,draw=black!50,fill=black!20,minimum size=5mm] {4};
\node at (-2,0) [place] {$B$};
\draw[line width=0.6mm] (-0.5,0.1) -- +(1,0) node[above] {};
\draw[line width=0.6mm] (-0.5,-0.1) -- +(1,0) node[above] {};
\end{tikzpicture}
\end{minipage}
\hspace{2cm} % Cambiar este espacio
\begin{minipage}[b]{0.2\linewidth}\centering
\begin{tikzpicture}[level distance=1.3cm,
level 1/.style={sibling distance=2cm, level distance=0.8cm},
level 2/.style={sibling distance=1cm, level distance=0.8cm},
level 3/.style={sibling distance=0.5cm, level distance=0.8cm}]%Se ocupo para poder separar el arbol creado en una distancia dada
\tikzstyle{every node}=[inner sep=0pt,minimum size=9mm, node distance=0.5pt]% define el cómo será cada nodo
\tikzstyle{edge from parent}=[red,->,thick,draw] %define el trazado o conexion que abrá entre cada nodo
\node [circle,draw=red!50,fill=red!20,thick]{$*$}%cabeza
child {node [circle,draw=yellow!50,fill=yellow!20,thick]{$2$}}
child {node [circle,draw=brown!50,fill=brown!20,thick]{$A$}%hijo der
};
\end{tikzpicture}
\end{minipage}
\hspace{2cm} % Cambiar este espacio
\begin{minipage}[b]{0.2\linewidth}
\centering
{\setlength{\arrayrulewidth}{1pt}
\begin{tabular}{|ccc|}
& & \\ \hline
&  & \\ \hline
&  & \\ \hline
\rowcolor {Brown}
& $B$ & \\ \hline
\end{tabular}
}
\end{minipage}
\end{table}

\subsectionanum{Construcción árbol representante de la derivada}
\newp Para construcción del árbol que contiene la expresión de la derivada de la expresión original basta aplicar las reglas de la derivación normales, las cuales son recursivas:
%\renewcommand{\labelitemi}{\ding{70}}
\begin{itemize}
\item Si el nodo raíz contiene un número o una variable que no es respecto a la cual se deriva la
expresión, el resultado es un nodo que contiene un cero.
\item Si el nodo raíz contiene la variable respecto a la cual se deriva la expresión el resultado es 
un nodo con el número 1
\item Si el nodo raíz contiene una operación entonces el resultado es un árbol que contiene la 
expresión correspondiente a la regla de la derivada para la operación:
$$(f \pm g )' = f'\pm g' $$
$$ (fg)' = f'g\  \pm fg'$$
$$\left(\frac{f}{g}\right)' = \left( \frac{f'g  \pm fg'}{g*g} \right)$$
\end{itemize}
\newp Es importante destacar que para el diseño de nuestro programa no se considero que las expresiones algebraicas fueran simplificadas en la división. También se consideran los casos de bordes en los cuales se divide por cero, donde se enviará un mensaje al usuario, luego de ingresar la expresión, que el código presenta un error de división por cero, que al derivar aún mantiene.
\newp En el caso que el usuario desee derivar expresiones como $1/x$ el signo menos que arroja la derivada de la expresión estará representado por un $(0 - 1)$ donde no se simplifica el signo menos para mantener la lógica del árbol del expresión.

\subsectionanum{Construcción de la expresión simplificada e imprimir en pantalla}
Para devolver el resultado simplificado de la expresión dada primero nos aseguramos que la expresión entregada ya esté simplificada, aunque se asume que el usuario entregaría esta expresión ya resulta desde antes, necesatando solamente su derivada.
\newp Después de analizar si el resultado entregado ya está simplificado, se comienza la derivación, y luego se simplifica nuevamente la expresión arrojada por la derivada, que en caso de seguir incluyendo ceros y/o unos que son despreciables en el resultado, son eliminados por el método \texttt{toStringArbol} el cual es el mismo que devuelve la expresión en String dado un árbol de expresión matemática.
\newp Finalmente la impresión en pantalla será el resultado del \texttt{String} dado, en formato in-fijo y el resultado de la derivada de la expresión.
\newp El esqueleto del programa quedaría de la siguiente manera:

\begin{sourcecodep}[\label{codigo}]{java}{basicstyle={\fontsize{9}{10}\selectfont\ttfamily},firstnumber=1}{Esqueleto del programa}
	class Arbol{//...
	}
	class Lista{//...
	}
	class Stack{//...
	}
	//Clase principal
	public class Mathematicas{//...
		public static void main(String[] args){//...
		}
		public static Arbol StackConstructor(String dato){//...
		}
		private static boolean esVariable(String s){//...
		}
		private static boolean esNumero(String s){//...
		}
		private static boolean esOperador(String s){//...
		}
		private static Arbol derivar(Arbol arbolNormal, String variable){//...
		}
		private static Arbol simplificar(Arbol arbol){//...
		}
		private static String toStringArbol(Arbol arbol){//...
		}
	}
\end{sourcecodep}

% ======================= IMPLEMENTACION =======================
\newpage
\sectionanum{Implementación}
En el desarrollo del trabajo, son necesarias 3 clases esenciales, \texttt{class Arbol, class Lista} y \texttt{class Stack}, las cuales están detalladas en el apunte.
 
\newp En respuesta a los datos ingresados, el programa responde con la expresión in-fijo de la expresión, y luego con la expresión in-fijo de la derivada de la expresión. Para simplificar problemas mayores a los solicitados se siguieron las siguientes reglas:

\begin{itemize}
	\item Las expresiones ingresadas tendrán las operaciones: suma (+), resta (-), multiplicación (*) y división (/).
	\item Las multiplicaciones de un término por 0 se reemplazan por 0.
	\item Las multiplicaciones de un término por 1 se reemplazan por el mismo término.
	\item Las sumas o restas de un término con 0 se reemplazan por el mismo término.
	\item Las divisiones de un término por 1 se reemplazan por el término.
	\item La expresión final omite los paréntesis que no son necesarios. Por ejemplo: 
		$$(((a * b) * c) + d) / e = (a * b * c + d) / e$$
Un ejemplo de salida simplificada es: $$(2 * x) + 1 + 0 = 2 * x + 1$$
\end{itemize}
Para lograr esto se siguió la secuencia señalada en la sección anterior:
\begin{enumerate}
\item \textbf{Construcción del árbol de la expresión utilizando una pila:}
\newp Para ello, en nuestro programa se creó el método \texttt{StackConstructor}(Código [\ref{codigo1}]), el cuál recibe un elemento tipo \texttt{String} y devuelve el árbol de expresión.

\begin{sourcecodep}[\label{codigo1}]{java}{basicstyle={\fontsize{9}{10}\selectfont\ttfamily},firstnumber=1}{Método \texttt{StackConstructor}}
	String[] ldato = dato.split(" "); //crea una lista con los Strings de la expresion dada.
	Stack stack = new Stack();
	Arbol error = new Arbol("Error al ingresar expresión");
	for (String miembro : ldato){
		if (esNumero(miembro)||esVariable(miembro)){
			Arbol a = new Arbol(miembro);
			stack.apilar(a);} //push
		else if (esOperador(miembro)){
			Arbol aux1 = stack.desapilar();
			Arbol aux2 = stack.desapilar();
			Arbol arbol = new Arbol(miembro, aux2, aux1);
			stack.apilar(arbol);}
		else return error;
	}
	Arbol a = stack.desapilar();
	return a;
\end{sourcecodep}

\item \textbf{Construcción del árbol de la expresión derivada:}
\newp Antes de empezar a derivar el árbol entregado por el método \texttt{StackConstructor}, creamos 3 métodos \textit{booleanos} que nos ayudarán a identificar si el nodo en donde nos encontremos \texttt{esVariable, esNumero or esOperador}, según las restricciones que analizamos en la sección anterior.
\newp Para la creación de este árbol se creó el método \texttt{derivar}(Código [\ref{codigo2}]), el cual, dado un \texttt{Arbol} de expresión, devuelve otro árbol que representa la derivada del árbol ingresado.

\begin{sourcecodep}[\label{codigo2}]{java}{basicstyle={\fontsize{9}{10}\selectfont\ttfamily},firstnumber=1}{Método \texttt{derivar}}
	Arbol derivada = new Arbol("");
	String v = arbolNormal.valor;
	Arbol i = arbolNormal.izq;
	Arbol d = arbolNormal.der;
	Arbol cero = new Arbol("0");
	Arbol uno = new Arbol("1");

	if (esNumero(v)) derivada = cero;
	else if (esVariable(v)){
		if (v.equals(variable)) derivada = uno;
		else derivada = cero;
	}
	else if (esOperador(v)){
		if (esNumero(i.valor) && esNumero(d.valor)) return cero;
		else if (v.equals("+")) derivada = new Arbol(v, derivar(i, variable),derivar(d, variable));
		else if(v.equals("-")) derivada = new Arbol(v, derivar(i, variable),derivar(d, variable));
		else if(v.equals("*")){
			Arbol a = new Arbol(v, derivar(i, variable), d);
			Arbol b = new Arbol(v, i, derivar(d, variable));
			derivada = new Arbol("+", a, b);
		}
		else if(v.equals("/")){
			Arbol numa = new Arbol("*", derivar(i, variable), d);
			Arbol numb = new Arbol("*", i, derivar(d,variable));
			Arbol num = new Arbol("-", numa, numb);
			Arbol div = new Arbol("*", d, d);
			derivada = new Arbol("/", num, div);
		}
	}
	return derivada;
\end{sourcecodep}
\newp El árbol entregado por \texttt{derivar} no es el árbol totalmente simplificado, si no que una expresión que representa la derivada total del \texttt{Arbol} ingresado inicialmente.
\newpage
\item \textbf{Simplificar el árbol de la expresión resultante:}
\newp Dado que el usuario al comienzo nos podría ingresar un árbol con expresiones innecesarias, y que la expresión del árbol que obtenemos del método \texttt{derivar} nos puede arrojar varios ceros y unos que tampoco son necesarios en el resultado final, se hizo necesario crear el método \texttt{simplificar} (Código [\ref{codigo3}]), que dado un Arbol de expresión, devuelve un \texttt{Arbol} simplificado hasta al menos una de sus hojas, donde en caso de presentarse casos (\texttt{Arbol} $\pm 0$) o (\texttt{Arbol} $* 0$), por ejemplo, el método \texttt{toStringArbol} será el encargado de simplificar esta expresión final, simplificando así de mejor manera la expresión.

\begin{sourcecodep}[\label{codigo3}]{java}{basicstyle={\fontsize{9}{10}\selectfont\ttfamily},firstnumber=1}{Método \texttt{simplificar} - Casos principales}
		if (arbol==null) return arbol;
		Arbol resumen = new Arbol("");
		String v = arbol.valor;
		Arbol i = arbol.izq;
		Arbol d = arbol.der;
		Arbol cero = new Arbol("0"); //en caso de multiplicación por 0 por ejemplo
		Arbol error = new Arbol("error");
		if (esNumero(v)) resumen = cero;
		else if (esVariable(v))	resumen = arbol;
		else if(esOperador(v)){
			//En caso que las hojas sean numeros o variables
			if((esVariable(i.valor)||esVariable(d.valor)) || (esNumero(d.valor)||esNumero(i.valor))){ //...
			}
			//En caso que solo la hoja del lado izquierdo sea operador
			if(esOperador(i.valor)){ //...
			}
			//En caso que solo la hoja del lado derecho sea operador
			if(esOperador(d.valor)){ //...
			}
			//En caso de que ambas hojas sean operadores
			if(esOperador(i.valor) && esOperador(d.valor)){ //...
			}
			//Si se salta todos los casos no es necesario simplificar, se devuelve el arbol ingresado
			resumen = new Arbol(v,i,d);
			return resumen;
		}
		return arbol;
\end{sourcecodep}
\newp Finalmente se genera el \texttt{output} del programa y se imprime en pantalla el resultado obtenido de la derivación.

\end{enumerate}
% ======================= MODO DE USO =======================
\newpage
\sectionanum{Modo de uso}
Para el uso correcto del programa se le recomienda al usuario seguir los siguientes pasos y considerar los supuestos expuestos en las secciones anteriores:
\begin{itemize}
\item Ingresar expresión matemática en polaca inversa, ya simplificada en lo posible (resuelta, sin operadores ni variables innecesarias) utilizando como variables las letras del  \href{http://aliso.pntic.mec.es/agalle17/cultura_clasica/alfabetos.htm}{Abecedario Castellano} \cite{ref1}. Presionar Enter.
\item Indicar la variable por la cual se piensa derivar. Presionar Enter.
\item Luego de que recibir el resultado, puede ingresar otra expresión, ingresar la expresión anterior bien expresada, ingresar la misma expresión o salir del programa apretando \texttt{Ctrl + C}, recibiendo un mensaje \quotes{EOF}. 
\end{itemize}
% ======================= RESULTADOS Y CONCLUSIONES =======================
{\small\sectionanum{Resultados}}
Los casos de prueba que se hicieron al programa fueron los ejemplos dados en el enunciado de la tarea, junto con casos bordes como multiplicación de ceros, unos o mostrar cuando se divide por cero:
\begin{enumerate}
\item \texttt{input: }\\
$> >\ 2\ x\ 3\ /\ *\ y\ x\ -\ +$\\
$> >\ x$\\
\texttt{output: }\\
1.-  Expresion in-fijo del arbol: $2\ *\ x\ /\ 3\ + \ (y\ -\ x)$ \\
2.-  Derivada de la expresion respecto a x : $2\ *\ 3\ /\ 3\ *\ 3\ +\ 1$\\
\item \texttt{input: }\\
$> >\ 2\ x\ 3\ /\ *\ y\ x\ -\ +$\\
$> >\ y$\\
\texttt{output: }\\
1.-  Expresion in-fijo del arbol: $2\ *\ x\ /\ 3\ + \ (y\ -\ x)$\\
2.-  Derivada de la expresion respecto a y : $1$\\
\item \texttt{input: }\\
$> >\ x\ 0\ +\ y\ 1\ /\ *$\\
$> >\ x$\\
\texttt{output: }\\
1.-  Expresion in-fijo del arbol: $x\ *\ y$\\
2.-  Derivada de la expresion respecto a x : $y$\\
\item \texttt{input: }\\
$> >\ 0\ 0\ 1\ /\ +\ 0\ 1\ -\ +$\\
$> >\ x$\\
\texttt{output: }\\
1.-  Expresion in-fijo del arbol: $1$\\
2.-  Derivada de la expresion respecto a x : $0$
\item \texttt{input: }\\
$> >\ 1\ x\ x\ *\ /$\\
$> >\ x$\\
\texttt{output: }\\
1.-  Expresion in-fijo del arbol: $1 / x * x$\\
2.-  Derivada de la expresion respecto a x : $(0 - (x + x)) / x * x * x * x$
\end{enumerate}

\sectionanum{Conclusión}
\newp Finalmente, podemos analizar que el trabajo realizado en conjunto con las clases \texttt{Arbol, Lista, Stack}, que fueron vitales para poder alcanzar los resultados obtenidos, es aprovechado con mayor eficacia con el uso de las propiedades de los arboles binarios, destacando el corto periodo de tiempo que tarda en hacer la recursión cada método, a pesar de la gran cantidad de \texttt{if} o \texttt{else if, else} que se colocaban en ellos.
\newp Sin embargo, es posible que el programa sea más eficaz de lo que ya es eliminando de alguna forma la recursividad en alguno de los métodos creados y lograr que el tiempo de ejecución para una expresión más larga de las que probamos en la sección anterior tarde menos tiempo.

% ======================= ANEXO =======================
\newpage
\sectionanum{Anexo}
\begin{sourcecodep}[\label{Codigo Final}]{java}{basicstyle={\fontsize{7}{10}\selectfont\ttfamily},firstnumber=27}{Código Final}
	import java.util.*;

	class Arbol{//revisar en apunte
	}
	class Lista{//revisar en apunte
	}
	class Stack{//revisar en apunte
	}
	//Clase principal
public class Mathematicas{
	public static void main(String[] args){
		Scanner sc= new Scanner(System.in);
		System.out.println("Ingrese primero la notacion polaca inversa:");
		while(sc.hasNextLine()){
			String s = sc.nextLine();
			System.out.println("Ingrese variable que desea derivar:");
			String variable = sc.nextLine(); 
			//ver que nos este dando un valor cierto
			int largo = s.length();
			int largov = variable.length();
			if(largo == 0){
				System.out.println("Error al ejecutar, ingrese todo de nuevo ");
			}
			else if (largov == 0){
				System.out.println("Error al ejecutar, ingrese todo de nuevo ");
			}
			else{
				Arbol arbol = StackConstructor(s);
				Arbol simplificadoArbol = simplificar(arbol);
				String simpArbol = toStringArbol(simplificadoArbol);
				System.out.println("1.-  Expresion in-fijo del arbol: " +simpArbol);
				Arbol derivada_arbol = derivar(simplificadoArbol, variable);
				Arbol simple = simplificar(derivada_arbol);
				String sim = toStringArbol(simple);
				System.out.println("2.-  Derivada de la expresion " + "respecto a " + variable + " : " +sim);
			}
		}
		System.out.println("EOF");//para chequear que se acaba el while pueden poner un print acá 
	}
	public static Arbol StackConstructor(String dato){
		String[] ldato = dato.split(" ");
		Stack stack = new Stack();
		Arbol error = new Arbol("Error al ingresar expresión");
		for (String miembro : ldato){
			//si el simbolo que se lee es una variable o un numero se crea un nodo, ie un arbol de expresion, con ese valor
			//y haremos push
			if (esNumero(miembro)||esVariable(miembro)){
				Arbol a = new Arbol(miembro);
				stack.apilar(a);
			}
			else if (esOperador(miembro)){
				Arbol aux1 = stack.desapilar();
				Arbol aux2 = stack.desapilar();
				Arbol arbol = new Arbol(miembro, aux2, aux1);
				stack.apilar(arbol);
			}
			else return error;
		}
		Arbol a = stack.desapilar();
		return a;
	}
	private static boolean esVariable(String s){
		String alfa = "aqwsedrftgyhujikolpñzxcvbnm";
		char car = s.charAt(0);
		for(int i=0; i<alfa.length();i++){
			char aux = alfa.charAt(i);
			if(car==aux){
				return true;
			}
		}
		return false;
	}
	private static boolean esNumero(String s){
		for(int i = 0; i<s.length(); i++){
			if(!Character.isDigit(s.charAt(i))){
				return false;
			}
		}
		return true;
	}
	private static boolean esOperador(String s){
		if(s.equals("+") || s.equals("/") || s.equals("*") || s.equals("-")) return true;
		return false;
	}
	private static Arbol derivar(Arbol arbolNormal, String variable){
		Arbol derivada = new Arbol("");
		String v = arbolNormal.valor;
		Arbol i = arbolNormal.izq;
		Arbol d = arbolNormal.der;
		Arbol cero = new Arbol("0");
		Arbol uno = new Arbol("1");
		if (esNumero(v)) derivada = cero;
		else if (esVariable(v)){
			if (v.equals(variable)) derivada = uno;
			else derivada = cero;
		}
		else if (esOperador(v)){
			if (esNumero(i.valor) && esNumero(d.valor)) return cero;
			else if (v.equals("+")) derivada = new Arbol(v, derivar(i, variable),derivar(d, variable));
			else if(v.equals("-")) derivada = new Arbol(v, derivar(i, variable),derivar(d, variable));
			else if(v.equals("*")){
				Arbol a = new Arbol(v, derivar(i, variable), d);
				Arbol b = new Arbol(v, i, derivar(d, variable));
				derivada = new Arbol("+", a, b);
			}
			else if(v.equals("/")){
				Arbol numa = new Arbol("*", derivar(i, variable), d);
				Arbol numb = new Arbol("*", i, derivar(d,variable));
				Arbol num = new Arbol("-", numa, numb);
				Arbol div = new Arbol("*", d, d);
				derivada = new Arbol("/", num, div);
			}
		}
		return derivada;
	}
	private static Arbol simplificar(Arbol arbol){
		if (arbol==null) return arbol;
		Arbol resumen = new Arbol("");
		String v = arbol.valor;
		Arbol i = arbol.izq;
		Arbol d = arbol.der;
		Arbol cero = new Arbol("0");
		Arbol error = new Arbol("error");
		if (esNumero(v)) resumen = cero;
		else if (esVariable(v))	resumen = arbol;
		else if(esOperador(v)){
			if((esVariable(i.valor)||esVariable(d.valor)) || (esNumero(d.valor)||esNumero(i.valor))){
				String vi = i.valor;
				String vd = d.valor;
				if(v.equals("*")){
					Arbol auxi = i;
					Arbol auxd = d;
					if((vi.equals("0") && esVariable(vd))||(esVariable(vi) && vd.equals("0"))){
						if (vi.equals("0")) return cero;
						else if (vd.equals("0")) return cero;
					}
					else if((vi.equals("1") && esVariable(vd))||(esVariable(vi) && vd.equals("1"))){
						if (esVariable(vi)) return auxi;
						else if (esVariable(vd)) return auxd;
					}
					else if((vi.equals("0") && esNumero(vd))||(esNumero(vi) && vd.equals("0"))){
						if (vi.equals("0")) return cero;
						else if (vd.equals("0")) return cero;
					}
					else if((esNumero(vi) && vd.equals("1"))||(vi.equals("1") && esNumero(vd))){
						if (esNumero(vi) && !vi.equals("1")) return auxi;
						else if (esNumero(vd) && !vd.equals("1")) return auxd;
					}
					//se acabo con *
				}
				// no se considera 0 - x, porque debe quedar asi (unica manera de representar los numeros negativos en el programa)
				else if(v.equals("+")){
					Arbol aux = i;
					Arbol auxd = d;
					if((esVariable(vi) && vd.equals("0"))||(vi.equals("0") && esVariable(vd))){
						if (esVariable(vi)) return i;
						else if (esVariable(vd)) return d; 
						}
					if((esNumero(vi) && vd.equals("0"))||(vi.equals("0") && esNumero(vd))){
						if (esNumero(vi) && !vi.equals("0")) return i;
						else if (esNumero(vd) && !vd.equals("0")) return d;
						else if (vi.equals("0") && vd.equals("0")) return cero;
						}
				}
				else if(v.equals("-")){
					Arbol aux = i;
					Arbol auxd = d;
					if((esVariable(vi)||esNumero(vi)) && vd.equals("0")) return i;
				}
				else if(v.equals("/")){
					Arbol aux = i;
					Arbol auxd = d;
					if(vi.equals("0")){
						if(esVariable(vd)) return cero;
						else if(esNumero(vd)) return cero;
					}
					else if(vd.equals("0")){
						if (esVariable(vi)){
							System.out.println("ERROR FATAL: Division Zero");
							return error;
						}
						else if (esNumero(vi)){
							System.out.println("ERROR FATAL: Division Zero");
							return error;
						}
					}
					else if(vd.equals("1")){
						if(esVariable(vi)) return i;
						else if (esNumero(vi)) return i;				
					}
				}
			}
			if(esOperador(i.valor)){
				if(esNumero(d.valor)){
				Arbol auxi = i;
				Arbol auxd = d;
					if (v.equals("*")){
						if(d.valor.equals("1")) return simplificar(i);
						else if(d.valor.equals("0")) return cero;
					}
					else if (v.equals("+") || v.equals("-")){
						if(d.valor.equals("0")) return simplificar(i);
					}
					else if(v.equals("/")){
						if(d.valor.equals("1")) return simplificar(i);
						else if (d.valor.equals("0")){
							System.out.println("ERROR FATAL: Divizion Zero");
							return error;
						}
					}
					else{
						Arbol izquierdo = simplificar(i);
						resumen = new Arbol(v,izquierdo,d);
						return resumen;
						}
				}
			}
			if(esOperador(d.valor)){
				if(esNumero(i.valor)){
				Arbol auxi = i;
				Arbol auxd = d;
				if(v.equals("/")){
					if(i.valor.equals("0")) return new Arbol("0");
				}
				if(v.equals("*")){
					if(i.valor.equals("0")) return new Arbol("0");				
					else if(i.valor.equals("1")){
						resumen = simplificar(auxd);
						return resumen;
					}
				}
				if(v.equals("+")){
					if(i.valor.equals("0")){
						resumen = simplificar(d);
						return resumen;
					}
				}
				else {
					Arbol derecho = simplificar(d);
					resumen = new Arbol(v,i,derecho);
					//return simplificar(resumen);
					return resumen;
					}
				}
			}
			if(esOperador(i.valor) && esOperador(d.valor)){
				Arbol izquierdo = simplificar(i);
				Arbol derecho = simplificar(d);
				resumen = new Arbol(v,simplificar(izquierdo),simplificar(derecho));
				return resumen;
			}
			resumen = new Arbol(v,i,d);
			return resumen;
		}
		return arbol;
	}
	private static String toStringArbol(Arbol arbol){
		if (arbol == null) return null;
		String v = arbol.valor;
		Arbol i = arbol.izq;
		Arbol d = arbol.der;
		Arbol cero = new Arbol("0");
		Arbol error = new Arbol("error");
		if (esNumero(v)){
			int algo = Integer.parseInt(v);
			if(algo == 0) return "0";
			return v;
		}
		else if(esVariable(v)){
			return v;
		}
		else if (esOperador(v)){
			String si = i.valor;
			String sd = d.valor;
			if (v.equals("*") || v.equals("/")){
				if(si.equals("0") && sd.equals("0")){
					if(v.equals("/")){
						System.out.println("ERROR FATAL: Division Zero");
						return toStringArbol(error);
					}
					return toStringArbol(cero);
				}
				else if(si.equals("0")) return toStringArbol(cero);
				else if(sd.equals("0")){
					if(v.equals("/")){
						System.out.println("ERROR FATAL: Division Zero");
						return toStringArbol(error);
					}
					return toStringArbol(cero);
				}
				else if(si.equals("+") || si.equals("-")){
					if (sd.equals("0")) return toStringArbol(cero);
					else if (sd.equals("1")) return toStringArbol(i);
					else if (sd.equals("+") || sd.equals("-")){
						return "(" + toStringArbol(i) + ") " + v + " (" + toStringArbol(d) + ")";
					}
					return "(" + toStringArbol(i) + ") " + v + " " +toStringArbol(d);
				}
				else if(sd.equals("+") || sd.equals("-")){
					if (si.equals("0")) return toStringArbol(cero);
					else if (si.equals("1")) return toStringArbol(d);
					if (si.equals("+") || si.equals("-")){
						return "(" + toStringArbol(i) + ") " + v + " (" + toStringArbol(d) + ")";
					}
					return toStringArbol(i) + " " + v + " (" + toStringArbol(d) + ")";
				}
			}
			else if (v.equals("+") || v.equals("-")){
				//dos lados cero
				if(si.equals("0") && sd.equals("0")){
					return toStringArbol(cero);
				}
				//lado izquierdo no es cero
				else if (sd.equals("0")){
					if(esOperador(si)) return toStringArbol(i);
					else if (esVariable(si) || esNumero(si)) return toStringArbol(i);
				}
				//lado derecho no es cero
				else if(si.equals("0")){
					String derecho = toStringArbol(d);
					int der_largo = derecho.length();
					if(esOperador(sd) && !v.equals("-") ) return toStringArbol(d);
					else if (esVariable(sd) || esNumero(sd)) return toStringArbol(d);
					else if (der_largo==1) return toStringArbol(i) + " " + v + " " + toStringArbol(d);
					else if (v.equals("-")) return toStringArbol(i) + " " + v + " (" + toStringArbol(d) + ")";
				}
				else if(si.equals("/") || si.equals("*")){
					if(sd.equals("+") || sd.equals("-")){
						String derecho = toStringArbol(d);
						int der_largo = derecho.length();
						if (der_largo==1) return toStringArbol(i) + " " + v + " " + toStringArbol(d);
						return toStringArbol(i) + " " + v + " (" + toStringArbol(d) + ")";
					}
				}
				else if(sd.equals("/") || sd.equals("*")){
					if(si.equals("+") || si.equals("-")){
						String izquierdo = toStringArbol(i);
						int izq_largo = izquierdo.length();
						if (izq_largo==1) return toStringArbol(i) + " " + v + " " + toStringArbol(d);
						return "(" + toStringArbol(i) + ") " + v + " " + toStringArbol(d);
					}
				}
			}
			else if ((si.equals("/") || sd.equals("/")) || (si.equals("*") || sd.equals("*"))){
				if(esNumero(si) || esVariable(si)) return toStringArbol(i) + " " + v + " (" + toStringArbol(d) + ")";
				else if(esNumero(sd) || esVariable(sd)) return "(" + toStringArbol(i) + ") " + v + " " + toStringArbol(d);
				return "("+ toStringArbol(i) + ") " + v + " (" + toStringArbol(d) + ")"; 
			}
			return toStringArbol(i) + " " + v + " " + toStringArbol(d);
		}
		return "(" + toStringArbol(i) + " " + v + " " + toStringArbol(d) + ")";
	}
}
\end{sourcecodep}



% ======================= REFERENCIAS =======================
\newpage
\begin{references}
	\bibitem{ref1}
	Ejemplos de Abecedarios
	\textit{Abecedario Castellano} \\
	\url{http://aliso.pntic.mec.es/agalle17/cultura_clasica/alfabetos.htm}

	\bibitem{ref2}
	Notación Polaca
	\textit{Notación polaca inversa} \\
	\url{https://es.wikipedia.org/wiki/Notaci%C3%B3n_polaca_inversa}

	\bibitem{ref3}
	Apunte Algoritmo y Estructuras de datos. 
	\textit{Tipos de datos abstractos - Universidad de Chile} \\
	\url{https://users.dcc.uchile.cl/~bebustos/apuntes/cc3001/TDA/}

\end{references}

% FIN DEL DOCUMENTO
\end{document}
